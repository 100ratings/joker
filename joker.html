<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Joker is Wild</title>
    <style>
        /* Basic Reset and Body Styling */
        :root {
            --card-aspect-ratio: 1.4; /* Standard playing card height/width ratio */
            --card-width: 350px;
        }

        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #FFF;
            font-family: sans-serif;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }
        
        #info {
            color: Grey;
            margin-bottom: 20px;
            font-size: 1.2rem;
            text-align: center;
        }

        /* Container for the card to maintain aspect ratio and stacking */
        #card-container {
            position: relative;
            width: var(--card-width);
            max-width: 90vw;
            height: calc(var(--card-width) * var(--card-aspect-ratio));
            max-height: 85vh;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
            border-radius: 15px;
            cursor: crosshair;
            -webkit-user-select: none; /* Safari */
            -ms-user-select: none; /* IE 10+ */
            user-select: none; /* Standard */
        }

        /* The revealed card image (bottom layer) */
        #card-image {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 15px;
            z-index: 1;
        }

        /* The scratchable canvas (top layer) */
        #scratch-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 15px;
            z-index: 2;
        }
    </style>
</head>
<body>

    <div id="info"></div>
    <div id="card-container">
        <!-- The revealed card image will be set by JavaScript -->
        <img id="card-image" src="" alt="Revealed Card">
        
        <!-- The scratchable Joker image will be drawn here -->
        <canvas id="scratch-canvas"></canvas>
    </div>

    <script type="text/javascript">

      var noSleep = new NoSleep();
      var nsEnabled = false;
      document.addEventListener('click', function() {
          if (!nsEnabled) {
              nsEnabled = true;
              noSleep.enable();
          }
      },false);
window.onpageshow = function(event) {
  if (event.persisted) {
      window.location.reload();
  }
};
  </script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const API_URL = 'https://11z.co/_w/YOURINJECTID/selection';
            const POLLING_INTERVAL = 3000; // 3 seconds

            const container = document.getElementById('card-container');
            const canvas = document.getElementById('scratch-canvas');
            const ctx = canvas.getContext('2d');
            const cardImage = document.getElementById('card-image');
            
            // This now tracks the card FILENAME we are showing, not the raw API value.
            let currentlyDisplayedCard = 'joker'; 
            let isDrawing = false;
            
            const jokerImage = new Image();
            jokerImage.src = 'img/cards/joker.webp';

            /**
             * Resizes the canvas to match its display size for crisp drawing.
             */
            function resizeCanvas() {
                canvas.width = container.clientWidth;
                canvas.height = container.clientHeight;
            }

            /**
             * Resets the canvas by clearing it and drawing the Joker image.
             * This is called on initial load and when a new card is fetched.
             */
            function resetCanvas() {
                // Ensure the image is loaded before trying to draw it
                if (jokerImage.complete) {
                    drawJoker();
                } else {
                    jokerImage.onload = drawJoker;
                }
            }
            
            function drawJoker() {
                // Clear any previous drawings
                ctx.globalCompositeOperation = 'source-over'; // Set to default drawing mode
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                // Draw the joker image to fill the canvas
                ctx.drawImage(jokerImage, 0, 0, canvas.width, canvas.height);
            }

            /**
             * Gets the coordinates of the mouse or touch event relative to the canvas.
             */
            function getCoords(e) {
                const rect = canvas.getBoundingClientRect();
                let x, y;
                
                if (e.touches && e.touches.length > 0) {
                    x = e.touches[0].clientX - rect.left;
                    y = e.touches[0].clientY - rect.top;
                } else {
                    x = e.clientX - rect.left;
                    y = e.clientY - rect.top;
                }
                return { x, y };
            }

            /**
             * The main drawing/scratching function.
             */
            function scratch(e) {
                if (!isDrawing) return;
                
                // Prevent default actions like scrolling on touch devices
                e.preventDefault(); 
                
                const { x, y } = getCoords(e);
                
                // 'destination-out' makes new shapes "erase" existing content
                ctx.globalCompositeOperation = 'destination-out';
                ctx.beginPath();
                // Draw a circle to erase
                ctx.arc(x, y, 20, 0, Math.PI * 2, false); 
                ctx.fill();
            }

            /**
             * Fetches the card value from the API and updates the UI if it's new.
             */
            async function fetchAndUpdateCard() {
                try {
                    const response = await fetch(API_URL);
                    if (!response.ok) throw new Error(`API Error: ${response.statusText}`);
                    
                    const data = await response.json();
                    const apiValue = data.value;

                    // **THE FIX IS HERE**
                    // Determine what card we INTEND to display. If the API value is invalid,
                    // we intend to display the 'joker'.
                    const cardToDisplay = (apiValue && typeof apiValue === 'string' && apiValue.trim() !== '') 
                        ? apiValue 
                        : 'joker';

                    // Only update if the card we intend to show is different from the one currently shown.
                    // This correctly handles ace -> joker, joker -> ace, and prevents updates for joker -> joker.
                    if (cardToDisplay !== currentlyDisplayedCard) {
                        console.log(`State change: '${currentlyDisplayedCard}' -> '${cardToDisplay}'`);
                        
                        // Update our state tracker
                        currentlyDisplayedCard = cardToDisplay;

                        cardImage.onload = () => {
                            resetCanvas();
                            console.log('Canvas reset. Revealed card is now:', cardImage.src.split('/').pop());
                        };

                        cardImage.onerror = () => {
                            console.error(`Failed to load image for '${cardToDisplay}'. Revealing Joker as fallback.`);
                            // If the image fails to load, our final state is 'joker'.
                            currentlyDisplayedCard = 'joker';
                            cardImage.src = 'img/cards/joker.webp';
                        };
                        
                        // Set the image source based on the card we decided to display.
                        cardImage.src = `img/cards/${cardToDisplay}.webp`;
                    }
                } catch (error) {
                    console.error('Failed to fetch card:', error);
                }
            }

            /**
             * Initializes the entire application.
             */
            function init() {
                resizeCanvas();
                window.addEventListener('resize', () => {
                    resizeCanvas();
                    resetCanvas(); // Redraw on resize
                });

                // Mouse Event Listeners
                canvas.addEventListener('mousedown', (e) => {
                    isDrawing = true;
                    scratch(e);
                });
                canvas.addEventListener('mousemove', scratch);
                canvas.addEventListener('mouseup', () => isDrawing = false);
                canvas.addEventListener('mouseleave', () => isDrawing = false);

                // Touch Event Listeners for mobile
                canvas.addEventListener('touchstart', (e) => {
                    isDrawing = true;
                    scratch(e);
                });
                canvas.addEventListener('touchmove', scratch);
                canvas.addEventListener('touchend', () => isDrawing = false);

                // Set initial state: reveal a joker and draw the scratchable joker on top.
                cardImage.src = 'img/cards/joker.webp';
                cardImage.onload = resetCanvas;

                // Initial fetch and start polling
                fetchAndUpdateCard();
                setInterval(fetchAndUpdateCard, POLLING_INTERVAL);
            }

            init();
        });
    </script>
</body>
</html>